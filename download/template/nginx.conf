server {
    listen 80;
    listen [::]:80;
    server_name {{domain}};
    server_tokens off;

    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }

    location / {
        return 301 https://$host$request_uri;
    }
}

limit_conn_zone $binary_remote_addr zone=download_addr:10m;

server {
    listen 443 ssl;
    listen [::]:443 ssl;
    http2 on;

    server_name {{domain}};
    server_tokens off;

    ssl_certificate /etc/nginx/ssl/live/{{domain}}/fullchain.pem;
    ssl_certificate_key /etc/nginx/ssl/live/{{domain}}/privkey.pem;
    ssl_trusted_certificate /etc/nginx/ssl/live/{{domain}}/chain.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'EECDH+AESGCM:EDH+AESGCM';
    ssl_session_cache shared:SSL_DOWNLOAD:10m;
    ssl_stapling on;
    ssl_stapling_verify on;
    resolver 8.8.8.8 8.8.4.4 valid=300s;
    resolver_timeout 5s;

    limit_conn download_addr 8;
    limit_rate 50m;

    root /volumes/content;

    types {
        text/plain md5 sha256 tsv txt;
        text/html html;
        application/octet-stream versatiles;
        application/rss+xml xml;
    }

    # Security headers
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }

    location / {
        sendfile           on;
        sendfile_max_chunk 1m;
    }

    # Local files (served from disk)
    {{#each localFiles}}
    location = {{{url}}} { alias {{{fullname}}}; }
    {{/each}}

    # Remote files (proxied via WebDAV)
    {{#each remoteFiles}}
    location = {{{url}}} {
        proxy_pass https://{{../webdavHost}}{{{webdavPath}}};
        proxy_set_header Host {{../webdavHost}};
        proxy_set_header Authorization "Basic {{../webdavAuth}}";
        proxy_ssl_server_name on;
        proxy_buffering off;
        proxy_request_buffering off;
        proxy_http_version 1.1;
        proxy_read_timeout 300s;
    }
    {{/each}}

    # Responses (inline content)
    {{#each responses}}
    location = {{{url}}} { return 200 "{{{content}}}"; }
    {{/each}}

    location = /robots.txt {
        default_type text/plain;
        return 200 "User-agent: *\nAllow: /\n";
    }

    location = / {
        try_files $uri $uri/ /index.html;
    }

    {{#if webhook}}
    location = /{{{webhook}}} {
        proxy_pass http://download-updater:8081/update;
    }
    {{/if}}
}
